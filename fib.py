import sys
import time
import math

# проверять на значении 35
# источники:
#	https://habr.com/ru/post/261159

def fib1(n):
	# Рекурсивное вычисление
	#
	# + Очень простая реализация, повторяющая математическое определение
	# - Экспоненциальное время выполнения. Для больших n очень медленно
	# ! Переполнение стека	
	if n == 0:
		return 0
	if n == 1:
		return 1
	return fib1(n-1)+fib1(n-2)

def fib2(n):
	# Решение с запоминанием
	#
	# + Превращает экспоненциальное время выполнения предыдущего алгоритма в линейное
	# - Тратит много памяти
	# ! Возможно переполнение стека, как и у рекурсии
	if n == 0:
		return 0
	a = [0]*(n+1)
	a[0] = 0
	a[1] = 1
	for i in range(2,n+1):
		a[i] = a[i-1] + a[i-2]
	return a[n]

def fib3(n):
	# Динамическое программирование
	# 
	# Вместо того, чтобы начинать с fib(n) и идти назад, можно начать с fib(0) и идти вперёд
	# Линейное время вполнения
	a = 0
	b = 1
	for __ in range(n):
		a, b = b, a + b
	return a

def fib4(n):
	# Вычисление по формуле Бине
	#
	# + Быстро и просто для малых n	
	# - Требуются операции с плавающей запятой. Для больших n потребуется большая точность
	# ! Использование комплексных чисел для вычисления Fn красиво с математической точки зрения, но уродливо — с компьютерной
	sqrt5 = math.sqrt(5)
	fi = (sqrt5 + 1) / 2 # золотое сечение
	return int(fi ** n / sqrt5 + 0.5)

################################################################################
# Матричная алгебра - наиболее правильный алгоритм
# Фиксированный объём памяти, логарифмическое время

#TODO

################################################################################

if len(sys.argv) != 2:
	print("Usage: %s n"%sys.argv[0])
else:
	n = int(sys.argv[1])
	start = time.time()
	nth = fib1(n)
	end = time.time()
	print(nth,end - start)

	start = time.time()
	nth = fib2(n)
	end = time.time()
	print(nth,end - start)

	start = time.time()
	nth = fib3(n)
	end = time.time()
	print(nth,end - start)

	start = time.time()
	nth = fib4(n)
	end = time.time()
	print(nth,end - start)
